/*
 * Copyright 2020 Atlassian
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.atlassian.migration.datacenter.core.aws.auth;

import com.atlassian.migration.datacenter.core.util.EncryptionManager;
import com.atlassian.sal.api.pluginsettings.PluginSettings;
import com.atlassian.sal.api.pluginsettings.PluginSettingsFactory;

import java.util.function.Supplier;

/**
 * Class for managing the storage and retrieval of AWS Credentials. Should not be used for direct access to credentials
 * except for in a CredentialsProvider implementation. This class stores credentials encrypted with a key generated by
 * the Spring Security Crypto library using its default AES encryption.
 */
public class EncryptedCredentialsStorage implements ReadCredentialsService, WriteCredentialsService {

    private static final String AWS_CREDS_PLUGIN_STORAGE_KEY = "com.atlassian.migration.datacenter.core.aws.auth";
    private static final String ACCESS_KEY_ID_PLUGIN_STORAGE_SUFFIX = ".accessKeyId";
    private static final String SECRET_ACCESS_KEY_PLUGIN_STORAGE_SUFFIX = ".secretAccessKey";


    private final EncryptionManager encryptionManager;
    private final Supplier<PluginSettingsFactory> pluginSettingsFactorySupplier;

    public EncryptedCredentialsStorage(Supplier<PluginSettingsFactory> pluginSettingsFactorySupplier,
                                       EncryptionManager encryptionManager) {
        this.pluginSettingsFactorySupplier = pluginSettingsFactorySupplier;
        this.encryptionManager = encryptionManager;
    }

    @Override
    public String getAccessKeyId() {
        // FIXME: Need to find a way to inject without calling the supplier every time
        PluginSettings pluginSettings = this.pluginSettingsFactorySupplier.get().createGlobalSettings();
        String raw = (String) pluginSettings.get(AWS_CREDS_PLUGIN_STORAGE_KEY + ACCESS_KEY_ID_PLUGIN_STORAGE_SUFFIX);
        return this.encryptionManager.decryptString(raw);
    }

    public void setAccessKeyId(String accessKeyId) {
        // FIXME: Need to find a way to inject without calling the supplier every time
        PluginSettings pluginSettings = this.pluginSettingsFactorySupplier.get().createGlobalSettings();
        pluginSettings.put(AWS_CREDS_PLUGIN_STORAGE_KEY + ACCESS_KEY_ID_PLUGIN_STORAGE_SUFFIX, this.encryptionManager.encryptString(accessKeyId));
    }

    @Override
    public void storeAccessKeyId(String accessKeyId) {
        this.setAccessKeyId(accessKeyId);
    }

    @Override
    public void storeSecretAccessKey(String secretAccessKey) {
        this.setSecretAccessKey(secretAccessKey);
    }

    @Override
    public String getSecretAccessKey() {
        // FIXME: Need to find a way to inject without calling the supplier every time
        PluginSettings pluginSettings = this.pluginSettingsFactorySupplier.get().createGlobalSettings();
        String raw = (String) pluginSettings.get(AWS_CREDS_PLUGIN_STORAGE_KEY + SECRET_ACCESS_KEY_PLUGIN_STORAGE_SUFFIX);
        return this.encryptionManager.decryptString(raw);
    }

    public void setSecretAccessKey(String secretAccessKey) {
        // FIXME: Need to find a way to inject without calling the supplier every time
        PluginSettings pluginSettings = this.pluginSettingsFactorySupplier.get().createGlobalSettings();
        pluginSettings.put(AWS_CREDS_PLUGIN_STORAGE_KEY + SECRET_ACCESS_KEY_PLUGIN_STORAGE_SUFFIX, this.encryptionManager.encryptString(secretAccessKey));
    }

}
